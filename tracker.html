<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Access Nature - Trail Tracker</title>
  <meta name="description" content="GPS trail tracking with accessibility documentation. Map outdoor routes and create comprehensive accessibility guides.">
  
  <!-- Preconnect to improve loading -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://unpkg.com">

  <!-- External CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css">
  
  <!-- External Resources -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" 
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  
  

  <style>
    /* CSS Reset and Base Styles */
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #000;
      color: #fff;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    /* Skip link for accessibility */
    .skip-link {
      position: absolute;
      top: -40px;
      left: 6px;
      background: #000;
      color: #fff;
      padding: 8px 16px;
      text-decoration: none;
      z-index: 10000;
      border-radius: 4px;
      font-weight: 500;
      transition: top 0.3s ease;
    }

    .skip-link:focus {
      top: 6px;
      outline: 3px solid #FFD700;
    }

    /* Main container */
    .container {
      position: relative;
      width: 100%;
      height: 100vh;
      overflow: hidden;
    }

    /* Full-screen map */
    #map {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    /* Status header - top banner */
    .status-header {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(12px);
      padding: 8px 24px;
      border-radius: 25px;
      z-index: 2000;
      display: flex;
      gap: 24px;
      align-items: center;
      box-shadow: 0 4px 25px rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.1);
      min-width: 280px;
    }

    .status-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      font-size: 0.85rem;
      flex: 1;
      min-width: 60px;
    }

    .status-value {
      font-size: 1.1rem;
      font-weight: bold;
      color: #4CAF50;
      font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      line-height: 1;
    }

    .status-label {
      font-size: 0.7rem;
      color: #ccc;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      margin-top: 2px;
      line-height: 1;
    }

    /* Compass section */
    .compass-section {
      position: fixed;
      top: 75px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 2000;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    .compass-container {
      position: relative;
      width: 60px;
      height: 60px;
      background: rgba(0, 0, 0, 0.85);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(12px);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
    }

    .compass-needle {
      position: absolute;
      width: 3px;
      height: 40px;
      transform-origin: 50% 50%;
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .compass-needle::before {
      content: '';
      position: absolute;
      top: -8px;
      left: -6px;
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-bottom: 20px solid #ff4444;
    }

    .compass-needle::after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: -4px;
      width: 0;
      height: 0;
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      border-top: 16px solid #ffffff;
    }

    .compass-reading {
      background: rgba(0, 0, 0, 0.8);
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: bold;
      color: #fff;
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      min-width: 60px;
      text-align: center;
    }

    /* Map rotation control */
    .rotation-control {
      position: fixed;
      top: 15px;
      right: 15px;
      width: 50px;
      height: 50px;
      background: rgba(0, 0, 0, 0.85);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      color: #fff;
      font-size: 1.2rem;
      cursor: pointer;
      z-index: 2000;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(12px);
      transition: all 0.3s ease;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
    }

    .rotation-control:hover {
      background: rgba(76, 175, 80, 0.85);
      border-color: rgba(76, 175, 80, 0.6);
      transform: scale(1.1);
    }

    .rotation-control.active {
      background: rgba(76, 175, 80, 0.9);
      border-color: #4CAF50;
    }

    /* Main tracking controls */
    .tracking-controls {
      position: fixed;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      z-index: 2000;
      align-items: center;
    }

    .control-btn {
      width: 60px;
      height: 60px;
      border: none;
      border-radius: 50%;
      font-size: 1.5rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(12px);
      box-shadow: 0 6px 25px rgba(0, 0, 0, 0.4);
      border: 2px solid rgba(255, 255, 255, 0.1);
      position: relative;
    }

    .accessibility-btn {
      background: rgba(33, 150, 243, 0.9);
      color: white;
    }

    .accessibility-btn:hover, .accessibility-btn:focus {
      background: rgba(33, 150, 243, 1);
      transform: scale(1.1);
      box-shadow: 0 8px 30px rgba(33, 150, 243, 0.4);
    }

    .play-btn {
      background: rgba(76, 175, 80, 0.9);
      color: white;
      width: 80px;
      height: 80px;
      font-size: 2rem;
    }

    .play-btn:hover, .play-btn:focus {
      background: rgba(76, 175, 80, 1);
      transform: scale(1.1);
      box-shadow: 0 8px 30px rgba(76, 175, 80, 0.4);
    }

    .play-btn.tracking {
      background: rgba(255, 152, 0, 0.9);
    }

    .play-btn.tracking:hover {
      background: rgba(255, 152, 0, 1);
      box-shadow: 0 8px 30px rgba(255, 152, 0, 0.4);
    }

    .play-btn.paused {
      background: rgba(33, 150, 243, 0.9);
    }

    .play-btn.paused:hover {
      background: rgba(33, 150, 243, 1);
      box-shadow: 0 8px 30px rgba(33, 150, 243, 0.4);
    }

    .save-btn {
      background: rgba(96, 125, 139, 0.6);
      color: #ccc;
    }

    .save-btn.ready {
      background: rgba(244, 67, 54, 0.9);
      color: white;
    }

    .save-btn.ready:hover, .save-btn.ready:focus {
      background: rgba(244, 67, 54, 1);
      transform: scale(1.1);
      box-shadow: 0 8px 30px rgba(244, 67, 54, 0.4);
    }

    /* Bottom menu */
    .bottom-menu {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(12px);
      padding: 12px 20px;
      border-radius: 25px;
      display: flex;
      gap: 30px;
      z-index: 2000;
      box-shadow: 0 6px 25px rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .menu-btn {
      background: none;
      border: none;
      color: #fff;
      padding: 8px;
      cursor: pointer;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      transition: all 0.3s ease;
      min-width: 50px;
    }

    .menu-btn:hover, .menu-btn:focus {
      background: rgba(255, 255, 255, 0.1);
      transform: translateY(-2px);
    }

    .menu-icon {
      font-size: 1.2rem;
      line-height: 1;
    }

    .menu-label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 0.8;
      line-height: 1;
    }

    .home-btn {
      background: rgba(255, 255, 255, 0.1);
    }

    /* Accessibility Modal */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 10000;
      backdrop-filter: blur(8px);
    }

    .modal-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #fff;
      width: 90%;
      max-width: 600px;
      max-height: 90vh;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      overflow: hidden;
      color: #333;
    }

    .modal-header {
      background: #2196F3;
      color: white;
      padding: 20px;
      position: relative;
    }

    .modal-header h2 {
      margin: 0;
      font-size: 1.3rem;
      font-weight: 600;
    }

    .modal-close-btn {
      position: absolute;
      top: 15px;
      right: 15px;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      width: 35px;
      height: 35px;
      border-radius: 50%;
      font-size: 1.2rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.3s ease;
    }

    .modal-close-btn:hover, .modal-close-btn:focus {
      background: rgba(255, 255, 255, 0.3);
    }

    .modal-body {
      padding: 0;
      max-height: calc(90vh - 140px);
      overflow-y: auto;
    }

    .accessibility-form {
      padding: 30px;
    }

    .accessibility-form fieldset {
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 25px;
      background: #fafafa;
    }

    .accessibility-form legend {
      font-weight: 600;
      color: #2196F3;
      padding: 0 10px;
      font-size: 1.1rem;
    }

    .accessibility-form .form-group {
      margin-bottom: 20px;
    }

    .accessibility-form label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: #333;
    }

    .accessibility-form input,
    .accessibility-form select,
    .accessibility-form textarea {
      width: 100%;
      padding: 12px;
      border: 2px solid #ddd;
      border-radius: 6px;
      font-size: 1rem;
      transition: border-color 0.3s ease;
    }

    .accessibility-form input:focus,
    .accessibility-form select:focus,
    .accessibility-form textarea:focus {
      outline: none;
      border-color: #2196F3;
      box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
    }

    .accessibility-form textarea {
      resize: vertical;
      min-height: 100px;
    }

    .radio-group, .checkbox-group {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .radio-item, .checkbox-item {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      padding: 8px;
      border-radius: 6px;
      transition: background-color 0.3s ease;
    }

    .radio-item:hover, .checkbox-item:hover {
      background: rgba(33, 150, 243, 0.05);
    }

    .radio-item input, .checkbox-item input {
      width: auto;
      margin: 0;
    }

    .form-actions {
      background: #f5f5f5;
      padding: 20px 30px;
      border-top: 1px solid #e0e0e0;
      display: flex;
      gap: 15px;
      justify-content: flex-end;
    }

    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      min-width: 100px;
    }

    .btn-primary {
      background: #2196F3;
      color: white;
    }

    .btn-primary:hover, .btn-primary:focus {
      background: #1976D2;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(33, 150, 243, 0.3);
    }

    .btn-secondary {
      background: #757575;
      color: white;
    }

    .btn-secondary:hover, .btn-secondary:focus {
      background: #616161;
    }

    /* Screen reader only content */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    /* Error and success messages */
    .error-message, .success-message {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 20px;
      border-radius: 8px;
      font-weight: 500;
      z-index: 10000;
      max-width: 90%;
      text-align: center;
      animation: slideInDown 0.3s ease-out;
    }

    .error-message {
      background: rgba(239, 68, 68, 0.95);
      color: white;
      border: 1px solid #dc2626;
    }

    .success-message {
      background: rgba(34, 197, 94, 0.95);
      color: white;
      border: 1px solid #16a34a;
    }

    @keyframes slideInDown {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }

    /* Improved tooltip styles */
    .control-btn, .menu-btn, .rotation-control, .modal-close-btn {
      position: relative;
    }

    .control-btn::after, .menu-btn::after, .rotation-control::after, .modal-close-btn::after {
      content: attr(title);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 14px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 1000;
      margin-bottom: 8px;
    }

    .control-btn:hover::after, .menu-btn:hover::after, .rotation-control:hover::after, .modal-close-btn:hover::after,
    .control-btn:focus::after, .menu-btn:focus::after, .rotation-control:focus::after, .modal-close-btn:focus::after {
      opacity: 1;
    }

    /* Special positioning for bottom menu tooltips */
    .menu-btn::after {
      bottom: auto;
      top: 100%;
      margin-bottom: 0;
      margin-top: 8px;
    }

    /* Compass container tooltip */
    .compass-container::after {
      content: attr(title);
      position: absolute;
      bottom: -30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .compass-container:hover::after {
      opacity: 1;
    }

    /* Mobile optimizations */
    @media (max-width: 480px) {
      .status-header {
        min-width: 250px;
        gap: 15px;
        padding: 6px 16px;
      }

      .status-item {
        min-width: 50px;
      }

      .status-value {
        font-size: 1rem;
      }

      .status-label {
        font-size: 0.65rem;
      }

      .tracking-controls {
        gap: 15px;
        bottom: 110px;
      }

      .control-btn {
        width: 50px;
        height: 50px;
        font-size: 1.2rem;
      }

      .play-btn {
        width: 65px;
        height: 65px;
        font-size: 1.5rem;
      }

      .bottom-menu {
        gap: 20px;
        padding: 10px 16px;
      }

      .menu-btn {
        min-width: 45px;
      }

      .menu-icon {
        font-size: 1.1rem;
      }

      .menu-label {
        font-size: 0.65rem;
      }
    }

    /* High contrast mode support */
    @media (prefers-contrast: high) {
      .control-btn, .menu-btn, .rotation-control {
        border-width: 3px;
      }
      
      .status-header, .bottom-menu, .compass-container {
        border-width: 2px;
      }
    }

    /* Reduced motion support */
    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        transition: none !important;
        animation: none !important;
      }
      
      .compass-needle {
        transition: none;
      }
    }
  </style>
</head>
<body>
  <!-- Skip link for accessibility -->
  <a href="#map" class="skip-link">Skip to map</a>

  <div class="container">
    <!-- Full-screen map -->
    <div id="map" role="application" aria-label="Interactive trail map"></div>

    <!-- Status Header -->
    <div class="status-header" role="status" aria-live="polite">
      <div class="status-item">
        <div class="status-value" id="timerDisplay" aria-label="elapsed time">00:00:00</div>
        <div class="status-label">Time</div>
      </div>
      <div class="status-item">
        <div class="status-value" id="distanceDisplay" aria-label="distance traveled">0.0 km</div>
        <div class="status-label">Distance</div>
      </div>
      <div class="status-item">
        <div class="status-value" id="pointsDisplay" aria-label="GPS points recorded">0</div>
        <div class="status-label">Points</div>
      </div>
    </div>

    <!-- Compass Section -->
    <div class="compass-section">
      <div class="compass-container" 
           title="Current compass heading and direction">
        <div id="compassNeedle" class="compass-needle"></div>
      </div>
      <div id="compassReading" class="compass-reading">0¬∞ N</div>
    </div>

    <!-- Map Rotation Control -->
    <button id="rotationToggle" class="rotation-control" 
            onclick="toggleMapRotation()"
            aria-label="Toggle map rotation with compass"
            title="Enable/disable map rotation to match your heading">
      <span class="compass-icon">üß≠</span>
    </button>

    <!-- Main Tracking Controls -->
    <div class="tracking-controls">
      <button id="accessibilityBtn" class="control-btn accessibility-btn" 
              onclick="openAccessibilityForm()"
              aria-label="Open accessibility survey"
              title="Document trail accessibility features and barriers">
        <span>‚ôø</span>
      </button>
      
      <button id="playPauseBtn" class="control-btn play-btn" 
              onclick="this.toggleTracking()"
              aria-label="Start tracking"
              title="Start GPS tracking of your route">
        <span>‚ñ∂</span>
      </button>
      
      <button id="saveBtn" class="control-btn save-btn" 
              onclick="saveRoute()"
              aria-label="Save route"
              title="Save your tracked route and accessibility data">
        <span>üíæ</span>
      </button>
    </div>

    <!-- Bottom Menu -->
    <nav class="bottom-menu" role="navigation" aria-label="Main actions">
      <button class="menu-btn" onclick="addNote()" 
              aria-label="Add note to current location"
              title="Add a note about trail conditions or accessibility features">
        <span class="menu-icon">üìù</span>
        <span class="menu-label">Note</span>
      </button>
      
      <button class="menu-btn" onclick="capturePhoto()" 
              aria-label="Take photo at current location"
              title="Capture photo documentation of trail features">
        <span class="menu-icon">üì∑</span>
        <span class="menu-label">Photo</span>
      </button>
      
      <button class="menu-btn home-btn" onclick="goHome()" 
              aria-label="Return to home page"
              title="Return to Access Nature home page">
        <span class="menu-icon">üè†</span>
        <span class="menu-label">Home</span>
      </button>
      
      <button class="menu-btn" onclick="openMenu()" 
              aria-label="Open main menu"
              title="Access export options, settings, and more features">
        <span class="menu-icon">‚ò∞</span>
        <span class="menu-label">Menu</span>
      </button>
    </nav>
  </div>

  <script type="module">
    // Import your existing modules with error handling
    let StorageManager, MapController, TrackingController, TimerController;
    let AccessibilityController, MediaController, ExportController;
    let FirebaseController, NavigationController, CompassController;
    let GeolocationUtils, CalculationUtils, HelperUtils;

    try {
      const storage = await import('./src/core/storage.js').catch(() => null);
      const map = await import('./src/core/map.js').catch(() => null);
      const tracking = await import('./src/core/tracking.js').catch(() => null);
      const timer = await import('./src/core/timer.js').catch(() => null);
      const accessibility = await import('./src/features/accessibility.js').catch(() => null);
      const media = await import('./src/features/media.js').catch(() => null);
      const exportMod = await import('./src/features/export.js').catch(() => null);
      const firebase = await import('./src/features/firebase.js').catch(() => null);
      const navigation = await import('./src/ui/navigation.js').catch(() => null);
      const compass = await import('./src/ui/compass.js').catch(() => null);
      const geolocation = await import('./src/utils/geolocation.js').catch(() => null);
      const calculations = await import('./src/utils/calculations.js').catch(() => null);
      const helpers = await import('./src/utils/helpers.js').catch(() => null);


      // Extract classes from modules
      StorageManager = storage?.StorageManager;
      MapController = map?.MapController;
      TrackingController = tracking?.TrackingController;
      TimerController = timer?.TimerController;
      AccessibilityController = accessibility?.AccessibilityController;
      MediaController = media?.MediaController;
      ExportController = exportMod?.ExportController;
      FirebaseController = firebase?.FirebaseController;
      NavigationController = navigation?.NavigationController;
      CompassController = compass?.CompassController;
      GeolocationUtils = geolocation?.GeolocationUtils;
      CalculationUtils = calculations?.CalculationUtils;
      HelperUtils = helpers?.HelperUtils;

    } catch (error) {
      console.log('Some modules not available, using fallback implementations');
    }

    // Enhanced tracking interface with comprehensive integration
    class ImprovedTrackingInterface {
      constructor() {
        this.state = 'idle'; // idle, tracking, paused
        this.heading = 0;
        this.isMapRotationEnabled = false;
        this.startTime = null;
        this.totalTime = 0;
        this.timerInterval = null;
        this.currentRoute = null;
        this.trackingData = [];
        
        // Initialize your existing controllers with proper error handling
        this.initializeControllers();
        
        // Set up event listeners and initialize UI
        this.setupEventListeners();
        this.initializeUI();
      }

      async initializeControllers() {
        try {
          // Initialize core controllers with your existing modules
          this.storage = StorageManager ? new StorageManager() : null;
          this.map = MapController ? new MapController('map') : null;
          this.tracking = TrackingController ? new TrackingController() : null;
          this.timer = TimerController ? new TimerController() : null;
          this.accessibility = AccessibilityController ? new AccessibilityController() : null;
          this.media = MediaController ? new MediaController() : null;
          this.export = ExportController ? new ExportController() : null;
          this.firebase = FirebaseController ? new FirebaseController() : null;
          this.navigation = NavigationController ? new NavigationController() : null;
          this.compass = CompassController ? new CompassController() : null;
          this.geolocation = GeolocationUtils ? new GeolocationUtils() : null;
          this.calculations = CalculationUtils ? new CalculationUtils() : null;
          this.helpers = HelperUtils ? new HelperUtils() : null;

          // Initialize map if available
          if (this.map) {
            await this.map.initializeMap();
            this.map.on('locationUpdate', (location) => this.handleLocationUpdate(location));
          }

          // Initialize compass tracking
          if (this.compass) {
            this.compass.on('headingUpdate', (heading) => this.updateCompass(heading));
          }

          // Initialize tracking controller
          if (this.tracking) {
            this.tracking.on('stateChange', (state) => this.updateTrackingState(state));
            this.tracking.on('routeUpdate', (data) => this.handleRouteUpdate(data));
          }

          // Initialize timer
          if (this.timer) {
            this.timer.on('tick', (time) => this.updateTimer(time));
          }

        } catch (error) {
          console.log('Some modules not available, using fallback implementations');
          this.initializeFallbacks();
        }
      }

      initializeFallbacks() {
        // Provide basic fallback functionality when modules aren't available
        if (!this.map) {
          console.log('MapController not available - using basic map fallback');
          this.initializeBasicMap();
        }
        if (!this.tracking) {
          console.log('TrackingController not available - using basic tracking fallback');
        }
      }

      initializeBasicMap() {
        // Initialize basic Leaflet map as fallback
        try {
          this.leafletMap = L.map('map').setView([51.505, -0.09], 13);
          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
          }).addTo(this.leafletMap);
        } catch (error) {
          console.error('Failed to initialize basic map:', error);
        }
      }

      setupEventListeners() {
        // Keyboard shortcuts for accessibility
        document.addEventListener('keydown', (e) => {
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
          
          switch(e.key) {
            case ' ': // Space
              e.preventDefault();
              this.toggleTracking();
              break;
            case 's':
            case 'S':
              if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                this.saveRoute();
              }
              break;
            case 'a':
            case 'A':
              if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                this.openAccessibilityForm();
              }
              break;
            case 'r':
            case 'R':
              if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                this.toggleMapRotation();
              }
              break;
            case 'p':
            case 'P':
              if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                this.capturePhoto();
              }
              break;
            case 'n':
            case 'N':
              if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                this.addNote();
              }
              break;
            case 'Escape':
              this.closeAccessibilityForm();
              break;
          }
        });

        // Handle orientation changes for mobile
        window.addEventListener('orientationchange', () => {
          if (this.map && this.map.resize) {
            setTimeout(() => this.map.resize(), 100);
          } else if (this.leafletMap) {
            setTimeout(() => this.leafletMap.invalidateSize(), 100);
          }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
          if (this.map && this.map.resize) {
            this.map.resize();
          } else if (this.leafletMap) {
            this.leafletMap.invalidateSize();
          }
        });
      }

      initializeUI() {
        // Set initial UI state
        this.updatePlayPauseButton();
        this.updateSaveButton();
        this.updateTimer();
        
        // Initialize compass
        this.updateCompass(0);
        
        // Load any existing route data
        this.loadExistingRoute();
      }

      async loadExistingRoute() {
        try {
          if (this.storage) {
            const existingRoute = await this.storage.getCurrentRoute();
            if (existingRoute) {
              this.currentRoute = existingRoute;
              this.trackingData = existingRoute.points || [];
              
              // Update UI to reflect existing route
              if (this.trackingData.length > 0) {
                this.updateSaveButton();
                
                // If route was in progress, offer to resume
                if (existingRoute.status === 'tracking') {
                  this.offerResumeTracking();
                }
              }
            }
          }
        } catch (error) {
          console.error('Error loading existing route:', error);
        }
      }

      offerResumeTracking() {
        // Implementation for offering to resume tracking
        if (confirm('You have an unfinished route. Would you like to continue tracking?')) {
          this.resumeTracking();
        }
      }

      resumeTracking() {
        this.state = 'tracking';
        this.startTime = Date.now() - (this.totalTime * 1000);
        this.startTimer();
        this.updatePlayPauseButton();
        
        if (this.tracking && this.tracking.resume) {
          this.tracking.resume();
        }
        
        this.announceToScreenReader('Resumed tracking existing route');
      }

      async toggleTracking() {
        try {
          if (this.state === 'idle') {
            // Start tracking
            await this.startTracking();
          } else if (this.state === 'tracking') {
            // Pause tracking
            this.pauseTracking();
          } else if (this.state === 'paused') {
            // Resume tracking
            this.resumeTrackingFromPause();
          }
        } catch (error) {
          console.error('Error toggling tracking:', error);
          this.showError('Unable to toggle tracking. Please check GPS permissions.');
        }
      }

      async startTracking() {
        // Request location permission if needed
        if (this.geolocation && !(await this.geolocation.checkPermission())) {
          const granted = await this.geolocation.requestPermission();
          if (!granted) {
            this.showError('Location permission is required for tracking');
            return;
          }
        }

        this.state = 'tracking';
        this.startTime = Date.now();
        this.totalTime = 0;
        this.trackingData = [];
        
        // Create new route
        this.currentRoute = {
          id: this.generateRouteId(),
          name: `Trail Route ${new Date().toLocaleDateString()}`,
          startTime: new Date(),
          status: 'tracking',
          points: [],
          accessibility: {},
          photos: [],
          notes: []
        };

        // Start tracking with existing controllers
        if (this.tracking) {
          await this.tracking.startTracking();
        }
        
        // Start timer
        this.startTimer();
        
        // Start location updates
        if (this.geolocation) {
          this.geolocation.startWatching((position) => {
            this.handleLocationUpdate(position);
          });
        } else if (navigator.geolocation) {
          // Fallback geolocation
          this.watchId = navigator.geolocation.watchPosition(
            (position) => this.handleLocationUpdate(position),
            (error) => console.error('Geolocation error:', error),
            { enableHighAccuracy: true, timeout: 5000, maximumAge: 60000 }
          );
        }
        
        // Update UI
        this.updatePlayPauseButton();
        this.updateSaveButton();
        
        // Save to storage
        if (this.storage) {
          await this.storage.saveCurrentRoute(this.currentRoute);
        }
        
        this.announceToScreenReader('Started tracking route');
      }

      pauseTracking() {
        this.state = 'paused';
        
        // Pause existing tracking
        if (this.tracking && this.tracking.pause) {
          this.tracking.pause();
        }
        
        // Stop timer but keep total time
        this.stopTimer();
        
        // Stop geolocation watching
        if (this.watchId) {
          navigator.geolocation.clearWatch(this.watchId);
          this.watchId = null;
        }
        
        // Update UI
        this.updatePlayPauseButton();
        
        this.announceToScreenReader('Paused tracking');
      }

      resumeTrackingFromPause() {
        this.state = 'tracking';
        this.startTime = Date.now() - (this.totalTime * 1000);
        
        // Resume existing tracking
        if (this.tracking && this.tracking.resume) {
          this.tracking.resume();
        }
        
        // Restart timer
        this.startTimer();
        
        // Restart location watching
        if (navigator.geolocation) {
          this.watchId = navigator.geolocation.watchPosition(
            (position) => this.handleLocationUpdate(position),
            (error) => console.error('Geolocation error:', error),
            { enableHighAccuracy: true, timeout: 5000, maximumAge: 60000 }
          );
        }
        
        // Update UI
        this.updatePlayPauseButton();
        
        this.announceToScreenReader('Resumed tracking');
      }

      async saveRoute() {
        if (!this.currentRoute || this.trackingData.length === 0) {
          this.showError('No route data to save');
          return;
        }

        try {
          // Stop tracking if still active
          if (this.state === 'tracking') {
            this.pauseTracking();
          }
          
          // Finalize route data
          this.currentRoute.endTime = new Date();
          this.currentRoute.status = 'completed';
          this.currentRoute.points = this.trackingData;
          this.currentRoute.duration = this.totalTime;
          
          // Calculate route statistics
          if (this.calculations) {
            this.currentRoute.distance = this.calculations.calculateDistance(this.trackingData);
            this.currentRoute.elevation = this.calculations.calculateElevationGain(this.trackingData);
          } else {
            // Basic distance calculation fallback
            this.currentRoute.distance = this.calculateBasicDistance();
          }

          // Save with existing controllers
          let saved = false;
          
          // Save to storage
          if (this.storage) {
            await this.storage.saveRoute(this.currentRoute);
            saved = true;
          }
          
          // Save to cloud if available
          if (this.firebase && this.firebase.saveRoute) {
            try {
              await this.firebase.saveRoute(this.currentRoute);
            } catch (cloudError) {
              console.warn('Cloud save failed, but local save succeeded:', cloudError);
            }
          }
          
          // Export route data
          if (this.export && saved) {
            // Offer export options
            this.showExportOptions();
          }
          
          // Reset state
          this.resetTracking();
          
          // Update UI
          this.updateSaveButton();
          this.updatePlayPauseButton();
          
          this.announceToScreenReader('Route saved successfully');
          this.showSuccess('Route saved successfully!');
          
        } catch (error) {
          console.error('Error saving route:', error);
          this.showError('Failed to save route. Please try again.');
        }
      }

      calculateBasicDistance() {
        // Basic distance calculation using Haversine formula
        let totalDistance = 0;
        for (let i = 1; i < this.trackingData.length; i++) {
          const prev = this.trackingData[i - 1];
          const curr = this.trackingData[i];
          totalDistance += this.haversineDistance(prev.lat, prev.lng, curr.lat, curr.lng);
        }
        return totalDistance;
      }

      haversineDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Earth's radius in kilometers
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
          Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
      }

      async openAccessibilityForm() {
        const modal = document.getElementById('accessibilityModal');
        if (modal) {
          modal.style.display = 'block';
          
          // Focus management
          const firstInput = modal.querySelector('input, select, textarea');
          if (firstInput) {
            setTimeout(() => firstInput.focus(), 100);
          }
          
          // Load existing accessibility data if available
          if (this.currentRoute && this.currentRoute.accessibility) {
            this.populateAccessibilityForm(this.currentRoute.accessibility);
          }
          
          this.announceToScreenReader('Opened accessibility survey');
        }
      }

      closeAccessibilityForm() {
        const modal = document.getElementById('accessibilityModal');
        if (modal) {
          // Save form data before closing
          this.saveAccessibilityData();
          
          modal.style.display = 'none';
          
          // Return focus to accessibility button
          const accessibilityBtn = document.getElementById('accessibilityBtn');
          if (accessibilityBtn) {
            accessibilityBtn.focus();
          }
          
          this.announceToScreenReader('Closed accessibility survey');
        }
      }

      async saveAccessibilityData() {
        try {
          const formData = this.collectAccessibilityFormData();
          
          if (this.currentRoute) {
            this.currentRoute.accessibility = { ...this.currentRoute.accessibility, ...formData };
            
            // Save to storage
            if (this.storage) {
              await this.storage.saveCurrentRoute(this.currentRoute);
            }
          }
          
          // Use existing accessibility controller if available
          if (this.accessibility && this.accessibility.saveAccessibilityData) {
            await this.accessibility.saveAccessibilityData(formData);
          }
          
        } catch (error) {
          console.error('Error saving accessibility data:', error);
        }
      }

      async capturePhoto() {
        try {
          if (this.media && this.media.capturePhoto) {
            const photo = await this.media.capturePhoto();
            
            if (photo && this.currentRoute) {
              // Add location data to photo
              if (this.trackingData.length > 0) {
                const currentLocation = this.trackingData[this.trackingData.length - 1];
                photo.location = {
                  lat: currentLocation.lat,
                  lng: currentLocation.lng,
                  timestamp: new Date()
                };
              }
              
              this.currentRoute.photos.push(photo);
              
              // Save to storage
              if (this.storage) {
                await this.storage.saveCurrentRoute(this.currentRoute);
              }
              
              this.announceToScreenReader('Photo captured and added to route');
              this.showSuccess('Photo captured successfully!');
            }
          } else {
            // Fallback for basic photo capture
            this.showPhotoCapture();
          }
        } catch (error) {
          console.error('Error capturing photo:', error);
          this.showError('Failed to capture photo. Please try again.');
        }
      }

      async addNote() {
        const noteText = prompt('Add a note about this location:');
        if (noteText && noteText.trim()) {
          const note = {
            id: this.generateNoteId(),
            text: noteText.trim(),
            timestamp: new Date(),
            location: null
          };
          
          // Add current location if available
          if (this.trackingData.length > 0) {
            const currentLocation = this.trackingData[this.trackingData.length - 1];
            note.location = {
              lat: currentLocation.lat,
              lng: currentLocation.lng
            };
          }
          
          if (this.currentRoute) {
            this.currentRoute.notes.push(note);
            
            // Save to storage
            if (this.storage) {
              await this.storage.saveCurrentRoute(this.currentRoute);
            }
          }
          
          this.announceToScreenReader('Note added to route');
          this.showSuccess('Note added successfully!');
        }
      }

      goHome() {
        // Check if tracking is active
        if (this.state === 'tracking') {
          const confirmLeave = confirm('You are currently tracking a route. Are you sure you want to leave? Your progress will be saved.');
          if (!confirmLeave) return;
          
          // Save current state
          this.pauseTracking();
          if (this.currentRoute) {
            this.storage?.saveCurrentRoute(this.currentRoute);
          }
        }
        
        // Navigate to home page
        if (this.navigation && this.navigation.goHome) {
          this.navigation.goHome();
        } else {
          // Fallback navigation
          window.location.href = 'index.html';
        }
      }

      openMenu() {
        // Implement menu opening logic
        this.showMainMenu();
      }

      toggleMapRotation() {
        this.isMapRotationEnabled = !this.isMapRotationEnabled;
        
        const rotationBtn = document.getElementById('rotationToggle');
        if (rotationBtn) {
          rotationBtn.classList.toggle('active', this.isMapRotationEnabled);
        }
        
        // Apply rotation to map if available
        if (this.map && this.map.setRotation) {
          this.map.setRotation(this.isMapRotationEnabled ? this.heading : 0);
        }
        
        const status = this.isMapRotationEnabled ? 'enabled' : 'disabled';
        this.announceToScreenReader(`Map rotation ${status}`);
      }

      updateCompass(heading) {
        this.heading = heading;
        
        // Update compass needle
        const needle = document.getElementById('compassNeedle');
        if (needle) {
          needle.style.transform = `rotate(${heading}deg)`;
        }
        
        // Update compass reading
        const reading = document.getElementById('compassReading');
        if (reading) {
          const direction = this.getCardinalDirection(heading);
          reading.textContent = `${Math.round(heading)}¬∞ ${direction}`;
        }
        
        // Apply rotation to map if enabled
        if (this.isMapRotationEnabled && this.map && this.map.setRotation) {
          this.map.setRotation(heading);
        }
      }

      getCardinalDirection(degrees) {
        const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 
                          'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
        const index = Math.round(degrees / 22.5) % 16;
        return directions[index];
      }

      startTimer() {
        this.timerInterval = setInterval(() => {
          this.totalTime = (Date.now() - this.startTime) / 1000;
          this.updateTimer();
        }, 1000);
      }

      stopTimer() {
        if (this.timerInterval) {
          clearInterval(this.timerInterval);
          this.timerInterval = null;
        }
      }

      updateTimer() {
        const display = document.getElementById('timerDisplay');
        if (display) {
          const hours = Math.floor(this.totalTime / 3600);
          const minutes = Math.floor((this.totalTime % 3600) / 60);
          const seconds = Math.floor(this.totalTime % 60);
          
          display.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
      }

      updatePlayPauseButton() {
        const btn = document.getElementById('playPauseBtn');
        if (!btn) return;
        
        // Remove all state classes
        btn.classList.remove('tracking', 'paused');
        
        switch(this.state) {
          case 'idle':
            btn.innerHTML = '<span>‚ñ∂</span>';
            btn.setAttribute('aria-label', 'Start tracking');
            btn.setAttribute('title', 'Start GPS tracking of your route');
            break;
          case 'tracking':
            btn.innerHTML = '<span>‚è∏</span>';
            btn.setAttribute('aria-label', 'Pause tracking');
            btn.setAttribute('title', 'Pause GPS tracking');
            btn.classList.add('tracking');
            break;
          case 'paused':
            btn.innerHTML = '<span>‚ñ∂</span>';
            btn.setAttribute('aria-label', 'Resume tracking');
            btn.setAttribute('title', 'Resume GPS tracking');
            btn.classList.add('paused');
            break;
        }
      }

      updateSaveButton() {
        const btn = document.getElementById('saveBtn');
        if (!btn) return;
        
        const hasData = this.trackingData.length > 0;
        btn.classList.toggle('ready', hasData);
        
        if (hasData) {
          btn.setAttribute('aria-label', 'Save route - data available');
          btn.setAttribute('title', 'Save your tracked route and accessibility data');
        } else {
          btn.setAttribute('aria-label', 'Save route - no data');
          btn.setAttribute('title', 'No route data to save');
        }
      }

      updatePointsDisplay() {
        const display = document.getElementById('pointsDisplay');
        if (display) {
          display.textContent = this.trackingData.length.toString();
        }
      }

      updateDistanceDisplay() {
        const display = document.getElementById('distanceDisplay');
        if (display) {
          const distance = this.calculateBasicDistance();
          display.textContent = `${distance.toFixed(1)} km`;
        }
      }

      // Helper and utility methods
      generateRouteId() {
        return 'route_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      }

      generateNoteId() {
        return 'note_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      }

      handleLocationUpdate(position) {
        const point = {
          lat: position.coords.latitude,
          lng: position.coords.longitude,
          altitude: position.coords.altitude,
          accuracy: position.coords.accuracy,
          timestamp: new Date(),
          speed: position.coords.speed,
          heading: position.coords.heading
        };

        // Add to tracking data
        this.trackingData.push(point);

        // Update map if available
        if (this.map && this.map.addPoint) {
          this.map.addPoint(point);
        } else if (this.leafletMap) {
          // Fallback: add marker to basic map
          L.marker([point.lat, point.lng]).addTo(this.leafletMap);
          this.leafletMap.setView([point.lat, point.lng]);
        }

        // Update route in storage
        if (this.currentRoute && this.storage) {
          this.currentRoute.points = this.trackingData;
          this.storage.saveCurrentRoute(this.currentRoute);
        }

        // Update compass if heading available
        if (point.heading !== null) {
          this.updateCompass(point.heading);
        }

        // Update displays
        this.updatePointsDisplay();
        this.updateDistanceDisplay();
        this.updateSaveButton();
      }

      handleRouteUpdate(routeData) {
        // Handle updates from the existing tracking controller
        if (routeData.points) {
          this.trackingData = routeData.points;
        }
        
        if (routeData.state) {
          this.updateTrackingState(routeData.state);
        }
      }

      updateTrackingState(newState) {
        this.state = newState;
        this.updatePlayPauseButton();
        this.updateSaveButton();
      }

      collectAccessibilityFormData() {
        const formData = {};
        
        // Collect all form fields
        const form = document.querySelector('#accessibilityModal form');
        if (form) {
          const formDataObj = new FormData(form);
          for (let [key, value] of formDataObj.entries()) {
            formData[key] = value;
          }
          
          // Handle checkboxes separately
          const checkboxes = form.querySelectorAll('input[type="checkbox"]:checked');
          const checkboxGroups = {};
          checkboxes.forEach(checkbox => {
            const name = checkbox.name;
            if (!checkboxGroups[name]) {
              checkboxGroups[name] = [];
            }
            checkboxGroups[name].push(checkbox.value);
          });
          
          // Merge checkbox groups
          Object.assign(formData, checkboxGroups);
        }
        
        return formData;
      }

      populateAccessibilityForm(data) {
        // Populate form fields with existing data
        const form = document.querySelector('#accessibilityModal form');
        if (form && data) {
          Object.keys(data).forEach(key => {
            const input = form.querySelector(`[name="${key}"]`);
            if (input) {
              if (input.type === 'checkbox' || input.type === 'radio') {
                input.checked = data[key] === input.value || data[key] === true;
              } else {
                input.value = data[key];
              }
            }
          });
        }
      }

      showExportOptions() {
        // Create and show export options modal/menu
        const exportOptions = ['GPX', 'JSON', 'PDF Trail Guide', 'HTML Guide'];
        const option = prompt(`Choose export format:\n${exportOptions.map((opt, i) => `${i + 1}. ${opt}`).join('\n')}`);
        
        if (option && this.export) {
          const optionIndex = parseInt(option) - 1;
          if (optionIndex >= 0 && optionIndex < exportOptions.length) {
            const format = exportOptions[optionIndex].toLowerCase().replace(' ', '_');
            this.export.exportRoute(this.currentRoute, format);
          }
        }
      }

      showMainMenu() {
        // Implement main menu functionality
        const menuOptions = [
          'Export Current Route',
          'View Route History', 
          'Settings',
          'Help',
          'About'
        ];
        
        // This could be expanded to show a proper modal menu
        const option = prompt(`Main Menu:\n${menuOptions.map((opt, i) => `${i + 1}. ${opt}`).join('\n')}`);
        
        if (option) {
          this.handleMenuSelection(parseInt(option) - 1);
        }
      }

      handleMenuSelection(index) {
        switch(index) {
          case 0: // Export
            this.showExportOptions();
            break;
          case 1: // History
            this.showRouteHistory();
            break;
          case 2: // Settings
            this.showSettings();
            break;
          case 3: // Help
            this.showHelp();
            break;
          case 4: // About
            this.showAbout();
            break;
        }
      }

      showRouteHistory() {
        if (this.storage && this.storage.getAllRoutes) {
          this.storage.getAllRoutes().then(routes => {
            // Display routes in a modal or navigate to history page
            console.log('Route history:', routes);
          });
        }
      }

      showSettings() {
        // Implement settings modal or navigate to settings page
        alert('Settings functionality would be implemented here');
      }

      showHelp() {
        // Show help modal or navigate to help page
        alert('Help documentation would be shown here');
      }

      showAbout() {
        // Show about modal
        alert('Access Nature Trail Tracker v1.0\nMaking outdoor spaces accessible for everyone.');
      }

      showPhotoCapture() {
        // Fallback photo capture using basic file input
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.capture = 'environment';
        
        input.addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (file) {
            // Convert to base64 or handle file as needed
            const photo = {
              id: 'photo_' + Date.now(),
              file: file,
              timestamp: new Date(),
              location: this.trackingData.length > 0 ? 
                this.trackingData[this.trackingData.length - 1] : null
            };
            
            if (this.currentRoute) {
              this.currentRoute.photos.push(photo);
              if (this.storage) {
                await this.storage.saveCurrentRoute(this.currentRoute);
              }
            }
            
            this.showSuccess('Photo added to route!');
          }
        });
        
        input.click();
      }

      resetTracking() {
        this.state = 'idle';
        this.startTime = null;
        this.totalTime = 0;
        this.trackingData = [];
        this.currentRoute = null;
        this.stopTimer();
        
        // Stop geolocation
        if (this.watchId) {
          navigator.geolocation.clearWatch(this.watchId);
          this.watchId = null;
        }
        
        // Clear map if available
        if (this.map && this.map.clearRoute) {
          this.map.clearRoute();
        } else if (this.leafletMap) {
          // Clear all markers from basic map
          this.leafletMap.eachLayer((layer) => {
            if (layer instanceof L.Marker) {
              this.leafletMap.removeLayer(layer);
            }
          });
        }
        
        // Reset tracking controller
        if (this.tracking && this.tracking.reset) {
          this.tracking.reset();
        }
        
        // Reset displays
        this.updatePointsDisplay();
        this.updateDistanceDisplay();
      }

      getCurrentRouteData() {
        return {
          route: this.currentRoute,
          trackingData: this.trackingData,
          totalTime: this.totalTime,
          state: this.state
        };
      }

      showError(message) {
        // Enhanced error display with accessibility
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.textContent = message;
        errorDiv.setAttribute('role', 'alert');
        errorDiv.setAttribute('aria-live', 'assertive');
        
        document.body.appendChild(errorDiv);
        
        // Remove after 5 seconds
        setTimeout(() => {
          if (errorDiv.parentNode) {
            errorDiv.parentNode.removeChild(errorDiv);
          }
        }, 5000);
      }

      showSuccess(message) {
        // Enhanced success display with accessibility
        const successDiv = document.createElement('div');
        successDiv.className = 'success-message';
        successDiv.textContent = message;
        successDiv.setAttribute('role', 'status');
        successDiv.setAttribute('aria-live', 'polite');
        
        document.body.appendChild(successDiv);
        
        // Remove after 3 seconds
        setTimeout(() => {
          if (successDiv.parentNode) {
            successDiv.parentNode.removeChild(successDiv);
          }
        }, 3000);
      }

      announceToScreenReader(message) {
        // Create temporary element for screen reader announcements
        const announcement = document.createElement('div');
        announcement.setAttribute('aria-live', 'polite');
        announcement.setAttribute('aria-atomic', 'true');
        announcement.className = 'sr-only';
        announcement.textContent = message;
        
        document.body.appendChild(announcement);
        
        // Remove after screen reader has time to announce
        setTimeout(() => {
          if (announcement.parentNode) {
            announcement.parentNode.removeChild(announcement);
          }
        }, 1000);
      }
    }

    // Initialize the enhanced tracking interface when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      // Initialize the tracking interface
      window.trackingInterface = new ImprovedTrackingInterface();
      
      // Set up additional accessibility enhancements
      setupAccessibilityEnhancements();
      
      // Handle potential service worker registration for PWA
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('./sw.js').catch(() => {
          console.log('Service worker registration failed');
        });
      }
    });

    function setupAccessibilityEnhancements() {
      // Add skip links for keyboard users
      const skipLink = document.createElement('a');
      skipLink.href = '#map';
      skipLink.className = 'skip-link';
      skipLink.textContent = 'Skip to map';
      document.body.insertBefore(skipLink, document.body.firstChild);
      
      // Enhance form accessibility
      const form = document.querySelector('#accessibilityModal form');
      if (form) {
        // Add aria-describedby relationships
        const inputs = form.querySelectorAll('input, select, textarea');
        inputs.forEach(input => {
          const label = form.querySelector(`label[for="${input.id}"]`);
          if (label && input.hasAttribute('required')) {
            label.innerHTML += ' <span aria-label="required">*</span>';
          }
        });
      }
      
      // Add keyboard event handlers for better accessibility
      document.addEventListener('keydown', (e) => {
        // Handle modal close with Escape
        if (e.key === 'Escape') {
          const modal = document.getElementById('accessibilityModal');
          if (modal && modal.style.display === 'block') {
            closeAccessibilityForm();
          }
        }
      });
      
      // Announce app readiness to screen readers
      setTimeout(() => {
        const announcement = document.createElement('div');
        announcement.setAttribute('aria-live', 'polite');
        announcement.className = 'sr-only';
        announcement.textContent = 'Access Nature tracker is ready. Use spacebar to start tracking, A to open accessibility survey.';
        document.body.appendChild(announcement);
        
        setTimeout(() => {
          if (announcement.parentNode) {
            announcement.parentNode.removeChild(announcement);
          }
        }, 3000);
      }, 1000);
    }

    // Utility function to handle module loading errors gracefully
    function handleModuleError(moduleName, error) {
      console.warn(`Module ${moduleName} failed to load:`, error);
      
      // Provide user feedback for critical failures
      if (['StorageManager', 'TrackingController'].includes(moduleName)) {
        const errorMsg = document.createElement('div');
        errorMsg.className = 'error-message';
        errorMsg.textContent = `Critical module ${moduleName} failed to load. Some features may not work properly.`;
        errorMsg.setAttribute('role', 'alert');
        document.body.appendChild(errorMsg);
        
        setTimeout(() => {
          if (errorMsg.parentNode) {
            errorMsg.parentNode.removeChild(errorMsg);
          }
        }, 10000);
      }
    }

    // Export for potential external use
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = { ImprovedTrackingInterface };
    }
  </script>
<!-- Accessibility Form Modal -->
  <div id="accessibilityOverlay" class="overlay hidden">
    <div id="accessibilityFormContainer" class="modal-container"></div>
  </div>

  <!-- Hidden File Inputs -->
  <input type="file" id="photoInput" accept="image/*" capture="environment" class="hidden">
  <input type="file" id="importFile" accept=".json,.gpx" class="hidden">

  <!-- External Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

  <!-- App JavaScript -->
  <script type="module" src="src/main.js"></script>
  <script type="module" src="src/features/auth.js"></script>
</body>
</html>
